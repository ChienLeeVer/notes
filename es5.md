### 数据类型

1.  基本数据类型：Number、String、Boolean、Object、特殊值Undefined、null

2.  检测数据类型的方法：typeof、instanceof、Object.prototype.toString()
    1. typeof: 返回值类型为字符串，‘number’、‘string’、‘boolean’、‘undefined’、‘function’、‘object’。注意：[]和null识别为object。因为数组是一种特殊的对象，而null在设计之初归类于object特殊值，js底层代码设定typeof null返回值为‘null’.
    2. instanceof
    3. Object.prototype.toString()

### null、undeifned和布尔值

1.  null表示空值、undefined表示未定义
2.  布尔值在前置逻辑运算符！、相等运算符==/!==、比较运算符>=，会返回布尔值。如果某个位置应当是布尔值，比如if判断句，JS会将undefined、null、0、‘’、false、NaN转为false，其他都转为true。

### 数值

1， 前提：JS内部所有数字都是以64位（8个字节）浮点数形式存储，意味着整数实质也是小数，需要使用整数时转为32位整数。（符号1位 + 指数部分11位 + 小数部分52位），指数决定大小、小数决定精度，计算结果 = (-1)^符号位 * 1.xx...xx * 2^指数部分。

2. 精度问题：二进制2^53以内可以保持精度，多出来的一位是JS规定的1.xx...xx的第一个1， 2^53 = 9007199254740992 ,计算结果这个数字以内的计算都不会出现计算错误。

3. 范围问题：2^11 = 2048, 0需要一位，因此指数部分表示数值大小的只有2047位，留出一半给负数，因此最大范围为2^1024~2^-1023,超出这个范围无法表示。超出2^1024返回Infinity，小于2^-1023返回0.

4.  表示方法：十六进制0x开头，八进制0o开头/0开头且只有0-7数字，二进制0b开头。

5.  特殊数字：
    1.  -0 === +0 === 0 ，内部比较不比较符号位。只有 （1 / +0） !== （1 / -0）转化为+Infinity和-Infinity
    2.  NaN : 将非数字的字符串解析为数字出错时的返回值，NaN不等于自身，转为布尔值为false,并且在任何比较运算或相等运算中出现NaN，判断结果均为false。在加减乘除中均返回NaN。

6.  parseInt(param)： 将参数转为字符串，如果一个字符串前面有空格会自动清除，如果遇到第一个非空格字符不是数字字符，则直接返回NaN，否则将字符串中的数字字符转为数字，直至遇到非数字字符，将已经转过的数字返回。注意：parseInt的第二个参数表示进制，代表第一个参数是几进制范围为2-36，通常第二个参数不写也没关系，parseInt()会自动识别第一个参数的进制，并将最终结果转换为十进制输出。如果故意输入0/null/undefined，parseInt()会忽略第二个参数。如果出现指定几进制，但是第一个参数出现了不该出现的数字，此时从最高位开始转，直至遇到非法数字，只返回可以转换的数值，否则返回NaN

7.  isNaN(): 用于判断一个值是否为NaN，返回true/false。参数类型为数值型，如果不是则用Number()转换。

### 字符串

1. 字符串一旦赋值即确定，无法通过下标修改某个字符，也无法修改length属性。
2. 字符串里的每个字符都是2个字节表示。这将导致某些特殊单个字符的length值为2，因为内部需要4个字节才能存储。
3. Base64转码：能将任意字符转为0-9、A-Z、a-z、+、/这64个字符。 btoa()转为Base64编码，atob()转为正常值。该方法不适合非ASCII码，如中文，除非使用encodeURIComponent()和decodeURIComponent()

### 对象

1.  基本概念：对象是无序键值对的集合
2.  键名：内部均转换为字符串
3.  歧义：单独的{}会被视为代码块，({})圆括号包裹起来被解释为表达式，里面的{}被视作对象
4.  属性的查看： Object.keys(obj)
5.  属性的删除： detelete obj.xx ,该方法删除一个不存在的属性不会报错，因为该操作不会对程序产生任何影响，且返回true，因为读取不存在的属性值为undefined
6.  判断一个属性是否存在： prop in obj ,使用in运算符即可, 缺点在于无法识别是否是继承属性还是自身属性，可以另外使用obj.hasOwinProperty(‘属性名’)
7.  属性的遍历： for in 循环遍历可遍历的属性，返回属性名（属性可能继承/自身）
8.  with语句：with (obj) { xx = XX }, 自能对已定义的属性进行操作，否则创建全局变量

### 函数

1.  声明方式：
    1.  function命令 function fnc(){}
    2.  匿名函数function() {},这种函数只能赋值给其他变量，如果给一个变量赋值一个有名函数，这个函数名只能在函数内部调用
    3.  Function()构造函数：Function(‘参数1’，‘参数2’， ‘参数3‘, ... , '函数体')
2. 第一等公民：函数本质是一个可执行的值，与基本类型值地位一样。因此函数名才会被提升到代码的头部，但是函数提升不适用于函数表达式。
3. 函数的属性和方法：
   1. func.name: 返回具名函数的名或者函数表达式变量名
   2. func.length: 返回剩余参数之前的形式参数个数，如果需要判断实际参数，使用argument.length
   3. func.toString(): 返回函数源码
4. 函数的作用域：
   1. 局部作用域：函数内部定义的变量称之为局部变量，只能在函数内部读取，除非提供外部访问接口（闭包）
   2. 函数内部的变量提升：函数内部用var定义的变量被提升到函数头部
   3. 函数本身的作用域： 在函数内部访问的变量在定义时就会确定访问的变量是哪一个作用域的，与运行时无关。（该知识点容易混淆：函数的作用域仅限于定义时，只有this是运行时确定，箭头函数中的this也是定义时确定）
5. 闭包： 闭包就是一个函数能够读取其他函数内部变量
   1. 优点：闭包能够延长变量的生命周期和封装对象的私有属性和方法。因为我们知道函数内的作用域是运行时确定的，当JS引擎发现，一个函数运行完毕后，仍然有其他函数需要该函数的运行环境时（比如使用当前运行环境的某个变量），不会对其环境和变量进行垃圾回收。
   2. 缺点：内存消耗大，每次运行一次函数都会产生一个新的闭包
6. eval命令：接受一个字符串作为参数，并当作语句执行，如果不是字符串原样返回。并且eval没有自身作用域。

### 数组

1.  概念：按次序排列的一组值。属于特殊的对象。因此可以赋值非数值键名
2.  length: 该属性只返回最大整数数值键名 + 1
3.  in运算符： 数组是一种特殊的对象，in运算符也可用于数组。
4.  for in循环：可以遍历数组中非数值的键值，因此不推荐使用for in遍历数组，而是forEach方法/for of。
5.  空位与undefined: [,,,]与[undefined,undefined,undefined]不同，前者称之为空位，访问空位值为undefined,在使用forEach/Object.keys/for of时会跳过前者的空位，但是不会跳过后者。
6.  类数组对象： argument/dom元素集/字符串，可以使用Array.prototype.slice.call(arrayLike)转为真正的数组/[...arrayLike]