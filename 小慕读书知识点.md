## 知识点列表
  * 路由和权限设计
  * 重定向
  * 登陆实现
## 路由和权限校验设计
---

### 关于路由处理
##### 流程图
![](/note/notes/Image/xiaomudushu/login_process.png)
##### 主要思路
   + vue-element-admin会在路由全局前置守卫router.beforeRach()对所有路由进行拦截校验
   + 校验逻辑主要分成两个部分：分析是否存在token
     + 如果Cookie中存在Token，判断当前路由是否在login页面，如果在login页面则应该重定向到后台路由。如果不在login页面表明当前在后台路由，则根据用户角色动态生成路由并访问对应路由，生成对应页面的组件。
     + 如果不存在Token,则判断当前路由是否在白名单内，如果不在白名单则表明应该登陆页面，此时将当前路由路径xxx生成一个redirect参数，并重定向到/login?redirect=xxx,目的为登陆后根据参数redirect直接重定向到用户想访问的路由。
##### 详细实现流程
+  在整个项目中main.js引入permission.js<br>`import ./permission.js`,目录如下：![](./Image/xiaomudushu/mulu-main.png)<br>permission主要内容如下
+  对所有路由进行拦截校验，判断是否存在token<br>
```
router.beforeEach(to, from, next) {
    //获取token，getToken方法在目录@/until/auth.js中实现，具体实现是通过Cookie.get(key)方法获取
    const hasToken = getToken()
    //根据token存在与否，判断路由是否跳转
    if(hasToken) {
        if(to.path === '/login') {
            //当前路由为login且存在token直接跳转到后台
            next('/')
        } else {
            //当前路由为后台且存在token，应该根据token获取用户角色列表
            //查看Vuex中是否存在用户角色,存在则路由已保存，直接跳转，不存在则尝试获取用户角色用于过滤并动态生成路由
            const hasRoles = store.getters.roles && store.getters.roles.length > 0
            if(hasRoles) {
                next()
            } else {
                try {
                    //获取用户角色，getInfo方法通过token访问api接口将用户信息保存在store中，并返回roles
                    const { roles } = await store.dispatch('user/getInfo')
                    //根据用户角色动态生成路由
                    const accessRoutes = await store.dispatch('permission/generateRoutes', roles)

                    router.addRoutes(accessRoutes)
                    //跳转到对应的路由
                    next({...to}, replace:  true)
                }catch (error) {
                    //获取角色失败则重置token并返回login页面
                    await store.dispatch('user/resetToken')
                    next(`/login?redirect=${to.path}`)
                }
            }
        }
    } else {
        //不存在token,则查看当前路由是否在白名单中,whiteList是一个数组，里面为白名单路由，如['login', '404']
        if(whiteList.includes(to.path)) {
            next()
        } else {
            next(`login?redirect=${to.path}`)
        }
    }

}
```


### 关于动态路由和权限设计

##### 流程图

![](/note/notes/Image/xiaomudushu/route_permission.jpg)
##### 主要思路
   + 将路由分为常规路由constRoutes和动态路由asyncRoutes
   + 用户登录系统时，会动态生成路由，其中常规路由是必备，而动态路由asyncRoutes需要过滤，将过滤后的asyncRoutes和constRoutes合并，合并后的路由保存到Vuex的permission/routes中。
   + asyncRoutes的过滤逻辑：逐一判断asyncRoutes中是否存在meta和meta.roles属性，如果不存在表明为通用的的动态路由，无需过滤。如果asyncRoutes存在该meta和meta.roles属性，将该属性和用户角色roles比较，如果roles中的某一项与meta.roles中的某一项匹配，则该路由也无需过滤。经过forEach逐一比较后得到过滤后的路由。
   + 用户登录系统后，侧边栏会从Vuex中获取state.permission.routes，根据该路由动态渲染用户菜单
##### 详细实现流程
```
//store中的action方法
generateRoutes({ commit }, roles) {
    return new Promise(resolve => {
        let accessRoutes
        //判断用户角色是否为管理员，如果为管理员应该获取全部asyncRoutes,否则需要对asyncRoutes过滤
        if(roles.includes('admin')) {
            accessRoutes = asyncRoutes || []
        } else {
            accessRoutes = filterAsyncRoutes(asyncRoutes, roles)

        }
         //将动态路由保存到Vuex中
        commit('SET_ROUTES', accessRoutes)
        resolve(accessRoutes)
    })
}

function filterRoutes(routes, roles) {
    let res = []
    routes.forEach(route => {
        let tmp = { ...route }
        if(hasPermission(roles, tmp)) {
            if(tmp.children) {
                tmp.children = filerRoutes(tmp.children, roles)
            }
            res.push(tmp)
        }

    })
    return res
}

function hasPermission( roles, route ) {
    if( route.meta && route.meta.roles ) {
        return roles.some(role => route.meta.roles.includes(role))
    } else {
        return true
    }
}

```

## 重定向
##### 实现思路
+ 在login组件页面对$route进行watch，将route.query.redirect保存下来，这个值在登陆成功后用于在 this. $router.push({path: this.redirect}),实现路由重定向
+ 在login.vue中监听
```
watch: {
    $route: {
      handler: function(route) {
        const query = route.query
        console.log(route);
        if (query) {
          this.redirect = query.redirect
          //获取其它查询条件
          this.otherQuery = this.getOtherQuery(query)
        }
      },
      //表示监听开始后立刻调用该handler函数
      immediate: true
    }
}
```
+ 点击登录，登陆成功后
```
handleLogin() {
      this.$refs.loginForm.validate(valid => {
        if (valid) {
          this.loading = true
          this.$store.dispatch('user/login', this.loginForm)
            .then(() => {
                //登陆成功后向history栈添加一个新的记录
              this.$router.push({ path: this.redirect || '/', query: this.otherQuery })
              this.loading = false
            })
            .catch(() => {
              this.loading = false
            })
        } else {
          console.log('error submit!!')
          return false
        }
      })
    }
```

## 登陆实现
##### 实现流程
###### 前提
  + vue通过vue-cli脚手架搭建项目后，需要配置路由，路由设计和校验已在上一节简述，这里不再赘述，启动项目，访问登陆页面localhost:8080/login,由于在路由守卫中cookie中无token，并且路由为/login属于白名单，因此无需再进行跳转

###### 前端
 + 登陆页面组件开发(views/login/index.vue)
   + 第一步：利用element-ui的element-form组件和组件的属性以及scss完成基本的页面样式布局
   + 第二部：为表单元素绑定响应式数据和表单校验规则，这一步用的是el-form的:model属性和el-form-item里的具体元素（如el-input）的v-model属性实现为表单元素绑定响应式数据。其次，利用el-form的:rules属性和每个el-form-item的prop属性一一绑定前端页面静态校验规则，具体校验代码请参考element-ui官网示例。如：
```
//js
data() {
    const validateUsername = (rule, value, callback) => {
      if (!value || value.length === 0) {
        callback(new Error('请输入正确的用户名'))
      } else {
        callback()
      }
    }
    const validatePassword = (rule, value, callback) => {
      if (value.length < 4) {
        callback(new Error('密码不能少于4位'))
      } else {
        callback()
      }
    return {

    //:rules=loginRules prop="username"
    loginRules: {
    username: [{ required: true, trigger: 'blur', validator: validateUsername }],
    password: [{ required: true, trigger: 'blur', validator: validatePassword }]
    },
}}
```
    + 第三步：在methods中为表单添加提交事件，这一步首先在html中给表单绑定ref,当提交事件触发后，该method中调用this.$refs.xx.validate()方法校验基本的输入规则是否通过，通过则通过this.$store.dispatch调用Vuex的action中写好的login方法，该操作涉及后端校验返回值类型为promise对象，因此直接链式调用，在then中直接进行后台页面路由跳转
+ 前端接口开发
    + 第一步：完成Vuex中action的login方法（目录：store/modules/user.js, 解释：store已经在app.js中注入，即引入store/index，而store/index.js则将modules里的所有js引入了,modules是为了区分不同业务模块，user.js对应用户登陆模块），在user.js的action对象的login方法中，做了两件事，一是返回一个promise对象，在promise中调用封装好的后端api（在user.js引入的@/api/user.js）,将传输过来的用户填写的信息一并作为参数传入api,由于api返回的也是一个promise对象，则直接链式调用then方法，参数为后端的返回值，二是取出返回值中的token，调用this.$store.commit()方法（需要自己写），将token保存在Vuex的state中，然后掉用在（@/utils/auth.js）封装好的方法将token保存在cookie中，然后resolve()，自此返回登陆组件页面开发中的第三步
    + 第二步：完成后端api,在/api/user.js中,这里统一暴露封装好的axios方法，如
  ```
  //后端api
  const request = import('@/utils/request')
  export function login(data) {
    return request({
        methods: 'post',
        url: '/user/login', //实际访问为baseURL + url
        data
    })
    }
  ```
   + 这里的request是在目录（@/utils/request.js）暴露的方法，在request.js中，axios.create()里配置后端访问接口和延迟时间，然后在设置请求和响应拦截器，然后return res，自此调用后端api得到返回值。
   + 第三步：axios的封装，在axios.create里，需要配置后端访问接口baseURL:process.env.xxx(process.env.xxx在项目根目录.env.development和.env.production中配置后端基础接口)，这一步涉及跨域请求（后端需要引入cors解决跨域问题），请求拦截器里主要根据是否有token而决定是否将token设置在请求头中，一并发送给后端。而响应拦截器里根据返回值是否正确而决定返回响应值/错误/重置token
###### 后端
